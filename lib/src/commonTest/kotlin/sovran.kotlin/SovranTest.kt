/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package sovran.kotlin

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import kotlin.test.*

class SovranTest : Subscriber {
    private val store = Store()

    @BeforeTest
    fun setup() {
//        store.reset()
    }

    @Test
    fun exampleCase() {

    }

    @Test
    fun testProvide() = runBlocking {
        store.provide(MessagesState())
        assertEquals(1, store.states.size)

        store.provide(UserState())
        assertEquals(2, store.states.size)
    }

    @Test
    fun testDoubleSubscribe() = runBlocking {
        // register some state
        store.provide(MessagesState())
        store.provide(UserState())

        // register some handlers for state changes
        val id1 = store.subscribe(this@SovranTest, MessagesState::class) { state ->
            print("unreadCount = $state.unreadCount")
        }

        // subscribe self to UserState twice.
        store.subscribe(this@SovranTest, UserState::class) { state ->
            print("username = $state.username")
        }

        // this should add a second listener for UserState
        val id3 = store.subscribe(this@SovranTest, UserState::class) { state ->
            print("username2 = $state.username")
        }

        // we should have 3 subscriptions.  2 for UserState, one for MessagesState.
        assertEquals(3, store.subscriptions.size)
        // we should have id1 + 2 = id3,
        // since the subscription ID has been increased twice since id1
        assertEquals(id1 + 2, id3)
    }

    @Test
    fun testDoubleProvide() = runBlocking {
        // register some state
        store.provide(MessagesState())
        store.provide(UserState())

        // this should do nothing since UserState has already been provided.
        // in use, this will assert in DEBUG mode, outside of tests.
        store.provide(UserState())

        assertEquals(2, store.states.size)
    }

    @Test
    fun testAlternateSubscriptionSyntax() = runBlocking {
        // this is more of a syntax test.  we don't really care if it's
        // a success, just that it builds.
        // register some state

        store.provide(MessagesState())

        // register some handlers for state changes
        store.subscribe(this@SovranTest, MessagesState::class) {
            print("hello")
        }

        val action = MessagesUnreadAction(22)
        store.dispatch(action, MessagesState::class)
    }

    @Test
    fun testSubscriptionIDIncrement() {
        val handler: Handler<MessagesState> = { _ ->
            print("booya")
        }
        val s1 = Store.Subscription(this, handler, MessagesState::class, Dispatchers.Default)
        val s2 = Store.Subscription(this, handler, MessagesState::class, Dispatchers.Default)
        val s3 = Store.Subscription(this, handler, MessagesState::class, Dispatchers.Default)

        assertTrue(s2.subscriptionID > s1.subscriptionID)
        assertTrue(s3.subscriptionID > s2.subscriptionID)
    }

    @Test
    fun testGetCurrentState() = runBlocking {
        val state = MessagesState(unreadCount = 1, outgoingCount = 2, messages = emptyList(), outgoing = emptyList())
        store.provide(state)

        val messageState = store.currentState(MessagesState::class)
        assertEquals(1, messageState?.unreadCount)
    }

}
